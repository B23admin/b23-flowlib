# Stateful processors in FlowLib #

There are several forms of state that need to be tracked when using FlowLib to deploy data flows to NiFi.

1. __Component state__ is the currently deployed instance(s) of a component. A single component might be included more than once in a given data flow, thus there are multiple deployed instances of that component. We consider component state to be the NiFi process group UUID of the deployed component

2. __Processor state__ is the current state of a stateful processor. Processor state is maintained in zookeeper. A single component may contain 0-N stateful processors.  During re-deployment of a component instance which contains 1 or more stateful processors, we need to be able to map the old component instance to the new component instance. Additonally we must be able to map the old stateful processors within the old instance to the new stateful processors in the new instance.  We can use this mapping to determine the previous processor ID and new processor ID so that we can update processor state in zookeeper during a re-deployment. Processors are determined to be stateful IFF the [ProcessorDTO.persists_state](https://nipyapi.readthedocs.io/en/latest/nipyapi-docs/nipyapi.nifi.models.html#nipyapi.nifi.models.processor_dto.ProcessorDTO.persists_state) is true, __however, state is only migrated during re-deployment if the state is [CLUSTER scoped](https://nipyapi.readthedocs.io/en/latest/nipyapi-docs/nipyapi.nifi.models.html#nipyapi.nifi.models.state_map_dto.StateMapDTO.scope)__. This is because it is impossible to set local state using the native NiFi rest APIs.  Therefore we can only migrate state if it is stored in zookeeper

> [IMPORTANT NOTE](https://nifi.apache.org/docs/nifi-docs/html/administration-guide.html#state_providers):
It should be noted that if Processors and other components save state using the Clustered scope, the Local State Provider will be used if the instance is a standalone instance (not in a cluster) or is disconnected from the cluster. This also means that if a standalone instance is migrated to become a cluster, then that state will no longer be available, as the component will begin using the Clustered State Provider instead of the Local State Provider.


## Idempotent deployments ##

1. When flowlib is used to deploy a flow to NiFi, it first checks to see whether a process group exists with the same name in NiFi's root process group.
2. A new process group is then created at the root canvas level named `(deploying) flow-name`
3. After all components are created successfully, we then check for existing state if we found a previously deployed flow during step 1.
4. If there is existing state in zookeeper, we migrate the old processors state to the new processor by using the processor path from `deployment.json` (e.g. `flow-name/component-instance-name/stateful-processor-name` below) to determine whether the processor existed previously.

> It is important to note that changes to the processor instance's path (such as changing a processor's name) will cause the state to not be migrated during a re-deployment

5. After state is migrated successfully, we delete the old flow's process group from NiFi and rename `(deploying) flow-name` to `flow-name`


## FlowDeployment Specification ##

A `deployment.json` is designed to be a self-contained representation of the flow and its components that were
deployed initially to the NiFi instance. The contents of `deployment.json` are stored in the flow process group's comments after a successful deployment. It is important to _never_ manually update the comments of a process group that was deployed by flowlib

See [deployment.json](./deployment.json) for a full example. This was generated by deploying the default project scaffold to a running NiFi instance

See the [FlowDeployment](../flowlib/model/deployment.py) model for the equivelant python class definition

```json
{
    "flow": {},                 // The raw flow.yaml definition stored as a json object.

    "root_group_id": "<uuid>",  // The NiFi uuid of the process group instance representing the deployed flow.
                                // Note: this is _not_ the same uuid as the root process group of the NiFi instance.

    "stateful_processors": {    // A map of stateful processors located at the
                                // flow.canvas level (not contained in a component).

        "update-filename": {    // The key is the name of the processor (flowlib.model.flow.Processor.name)
            "processor_id": "<uuid>"  // The NiFi uuid of the processor instance
        }
    },
    "components": [             // An array of components that are used by this flow
        {
            "component": {},    // The raw component.yaml definition stored as a json object.

            "stateful_processors": {    // A dict(str:object) which maps the stateful processors to its

                "flow-name/component-instance-name/stateful-processor-name": { // The key is the path within the flow to the stateful processor instance

                    "group_id": "<uuid>",   // The NiFi uuid of the process group representing this component instance

                    "processor_id": "<uuid>",   // The NiFi uuid of the processor representing this stateful processor instance

                    "state": {} // A dict(str:str) containing k,v pairs of this processor's state stored in zookeeper
                }
            }

        }
    ]
}
```


### Connecting to zookeeper in a running container ###

```bash
wget https://apache.claz.org/zookeeper/zookeeper-3.5.6/apache-zookeeper-3.5.6-bin.tar.gz
tar xvf ./apache-zookeeper-3.5.6-bin.tar.gz
cd apache-zookeeper-3.5.6-bin
./bin/zkCli.sh -server localhost:2181
```
